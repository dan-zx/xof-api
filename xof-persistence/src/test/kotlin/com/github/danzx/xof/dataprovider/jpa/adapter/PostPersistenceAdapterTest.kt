package com.github.danzx.xof.dataprovider.jpa.adapter

import com.github.danzx.xof.core.domain.Ids
import com.github.danzx.xof.core.domain.Post
import com.github.danzx.xof.core.domain.SimpleUser
import com.github.danzx.xof.core.filter.PostsFilter
import com.github.danzx.xof.core.filter.dsl.postsWith
import com.github.danzx.xof.core.filter.dsl.title
import com.github.danzx.xof.core.filter.dsl.userId
import com.github.danzx.xof.dataprovider.jpa.repository.PostJpaRepository
import com.github.danzx.xof.dataprovider.jpa.repository.PostVoteJpaRepository
import com.github.danzx.xof.dataprovider.jpa.repository.UserJpaRepository
import com.github.danzx.xof.dataprovider.jpa.test.TEST_POST
import com.github.danzx.xof.dataprovider.jpa.test.TEST_USER

import io.kotlintest.shouldBe
import io.kotlintest.shouldNotBe

import org.junit.jupiter.api.BeforeEach
import org.junit.jupiter.api.Test
import org.junit.jupiter.params.ParameterizedTest
import org.junit.jupiter.params.provider.Arguments.arguments
import org.junit.jupiter.params.provider.MethodSource

import org.springframework.beans.factory.annotation.Autowired
import org.springframework.test.context.jdbc.Sql

import java.time.LocalDateTime
import java.util.stream.Stream

class PostPersistenceAdapterTest : PersistenceAdapterBaseTest() {

    @Autowired lateinit var postJpaRepository: PostJpaRepository
    @Autowired lateinit var postVoteJpaRepository: PostVoteJpaRepository
    @Autowired lateinit var userJpaRepository: UserJpaRepository

    lateinit var adapter: PostPersistenceAdapter

    @BeforeEach
    fun onBeforeTest() {
        adapter = PostPersistenceAdapter()
        adapter.postVoteJpaRepository = postVoteJpaRepository
        adapter.postJpaRepository = postJpaRepository
        adapter.userJpaRepository = userJpaRepository
    }

    @Test
    @Sql("classpath:test-user.sql")
    fun `should save return non null post with non negative id`() {
        val autoGeneratedId = Ids.AUTO_GENERATED
        val post = Post(
            id = autoGeneratedId,
            title = "My Title",
            content = "My content",
            created = LocalDateTime.of(2020, 12, 8, 8, 10, 40),
            updated = LocalDateTime.of(2020, 12, 8, 8, 10, 40),
            votes = 0,
            user = SimpleUser(
                id = TEST_USER.id,
                username = TEST_USER.username
            )
        )

        adapter.save(post)
        val actual = adapter.loadById(post.id)

        actual shouldNotBe null
        actual!!.id shouldNotBe autoGeneratedId
        post shouldBe actual
    }

    @ParameterizedTest
    @MethodSource("filtersAndExpectedResults")
    @Sql("classpath:test-user.sql",
         "classpath:test-post.sql",
         "classpath:test-post-vote.sql")
    fun `should load paginated return non null result`(filter: PostsFilter, expected: List<Post>) {
        adapter.loadPaginated(filter).data shouldBe expected
    }

    @Test
    @Sql("classpath:test-user.sql",
         "classpath:test-post.sql",
         "classpath:test-post-vote.sql")
    fun `should load by id return non null post when post exists`() {
        val actual = adapter.loadById(TEST_POST.id)

        actual shouldNotBe null
        actual shouldBe TEST_POST
    }

    @Test
    fun `should load by id return null when post does not exist`() {
        adapter.loadById(TEST_POST.id) shouldBe null
    }

    @Test
    @Sql("classpath:test-user.sql",
         "classpath:test-post.sql",
         "classpath:test-post-vote.sql")
    fun `should exists by id return true when post exists`() {
        adapter.existsId(TEST_POST.id) shouldBe true
    }

    @Test
    fun `should exists by id return false when post does not exist`() {
        adapter.existsId(TEST_POST.id) shouldBe false
    }

    @Test
    @Sql("classpath:test-user.sql",
         "classpath:test-post.sql",
         "classpath:test-post-vote.sql")
    fun `should update return non null updated user`() {
        val post = adapter.loadById(TEST_POST.id)
        post shouldNotBe null

        post!!.apply {
            title = "My Title"
            content = "My content"
            created = LocalDateTime.of(2020, 12, 8, 8, 10, 40)
            updated = LocalDateTime.of(2020, 12, 8, 8, 10, 40)
            votes = 0
            user = SimpleUser(
                id = TEST_USER.id,
                username = TEST_USER.username
            )
        }

        adapter.update(post)
        val expected = adapter.loadById(TEST_POST.id)

        post shouldNotBe null
        post shouldBe expected
    }

    @Test
    @Sql("classpath:test-user.sql",
         "classpath:test-post.sql",
         "classpath:test-post-vote.sql")
    fun `should remove by id delete post when user exists`() {
        var user = adapter.loadById(TEST_POST.id)
        user shouldNotBe null

        adapter.removeById(TEST_POST.id)

        user = adapter.loadById(TEST_POST.id)
        user shouldBe null
    }

    companion object {

        @JvmStatic
        fun filtersAndExpectedResults() =
            Stream.of(
                arguments(PostsFilter.NONE, listOf(TEST_POST)),
                arguments(postsWith { userId eq TEST_POST.user.id; title containing TEST_POST.title }, listOf(TEST_POST)),
                arguments(postsWith { userId eq TEST_POST.user.id }, listOf(TEST_POST)),
                arguments(postsWith { title containing TEST_POST.title }, listOf(TEST_POST)),
                arguments(postsWith { title containing "nothing" }, emptyList<Post>())
            )
    }
}