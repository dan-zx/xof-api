package com.github.danzx.xof.dataprovider.jpa.adapter

import com.github.danzx.xof.core.domain.Ids
import com.github.danzx.xof.core.domain.Comment
import com.github.danzx.xof.core.domain.SimpleUser
import com.github.danzx.xof.core.filter.CommentsFilter
import com.github.danzx.xof.core.filter.dsl.commentsWith
import com.github.danzx.xof.core.filter.dsl.parentId
import com.github.danzx.xof.core.filter.dsl.postId
import com.github.danzx.xof.core.filter.dsl.userId
import com.github.danzx.xof.dataprovider.jpa.repository.CommentJpaRepository
import com.github.danzx.xof.dataprovider.jpa.repository.CommentVoteJpaRepository
import com.github.danzx.xof.dataprovider.jpa.repository.PostJpaRepository
import com.github.danzx.xof.dataprovider.jpa.repository.UserJpaRepository
import com.github.danzx.xof.dataprovider.jpa.test.TEST_COMMENT
import com.github.danzx.xof.dataprovider.jpa.test.TEST_USER

import io.kotlintest.shouldBe
import io.kotlintest.shouldNotBe

import org.junit.jupiter.api.BeforeEach
import org.junit.jupiter.api.Test
import org.junit.jupiter.params.ParameterizedTest
import org.junit.jupiter.params.provider.Arguments.arguments
import org.junit.jupiter.params.provider.MethodSource

import org.springframework.beans.factory.annotation.Autowired
import org.springframework.test.context.jdbc.Sql

import java.time.LocalDateTime
import java.time.LocalDateTime.now
import java.util.stream.Stream

class CommentPersistenceAdapterTest : PersistenceAdapterBaseTest() {

    @Autowired lateinit var commentJpaRepository: CommentJpaRepository
    @Autowired lateinit var commentVoteJpaRepository: CommentVoteJpaRepository
    @Autowired lateinit var postJpaRepository: PostJpaRepository
    @Autowired lateinit var userJpaRepository: UserJpaRepository

    lateinit var adapter: CommentPersistenceAdapter

    @BeforeEach
    fun onBeforeTest() {
        adapter = CommentPersistenceAdapter()
        adapter.commentVoteJpaRepository = commentVoteJpaRepository
        adapter.commentJpaRepository = commentJpaRepository
        adapter.postJpaRepository = postJpaRepository
        adapter.userJpaRepository = userJpaRepository
    }

    @Test
    @Sql("classpath:test-user.sql",
         "classpath:test-post.sql")
    fun `should save return non null comment with non negative id`() {
        val autoGeneratedId = Ids.AUTO_GENERATED
        val comment = TEST_COMMENT.copy(id = autoGeneratedId, votes = 0)

        adapter.save(comment)
        val actual = adapter.loadById(comment.id)

        actual shouldNotBe null
        actual!!.id shouldNotBe autoGeneratedId
        actual shouldBe TEST_COMMENT.copy(id = actual.id, votes = 0)
    }

    @Test
    @Sql("classpath:test-user.sql",
         "classpath:test-post.sql",
         "classpath:test-comment.sql",
         "classpath:test-comment-vote.sql")
    fun `should load parent comment when parent comment exists`() {
        var comment = TEST_COMMENT.copy(
            id = Ids.AUTO_GENERATED,
            created = now(),
            parentId = TEST_COMMENT.id,
            votes = 0)

        comment = adapter.save(comment)

        comment.parentId shouldNotBe null
        comment.parentId!! shouldBe TEST_COMMENT.id
    }

    @ParameterizedTest
    @MethodSource("filtersAndExpectedResults")
    @Sql("classpath:test-user.sql",
         "classpath:test-post.sql",
         "classpath:test-comment.sql",
         "classpath:test-comment-vote.sql")
    fun `should load paginated return non null result`(filter: CommentsFilter, expected: List<Comment>) {
        adapter.loadPaginated(filter).data shouldBe expected
    }

    @Test
    @Sql("classpath:test-user.sql",
         "classpath:test-post.sql",
         "classpath:test-comment.sql",
         "classpath:test-comment-vote.sql")
    fun `should load by id return non null comment when comment exists`() {
        val actual = adapter.loadById(TEST_COMMENT.id)

        actual shouldNotBe null
        actual shouldBe TEST_COMMENT
    }

    @Test
    fun `should load by id return null when comment does not exist`() {
        adapter.loadById(TEST_COMMENT.id) shouldBe null
    }

    @Test
    @Sql("classpath:test-user.sql",
         "classpath:test-post.sql",
         "classpath:test-comment.sql",
         "classpath:test-comment-vote.sql")
    fun `should exists by id return true when comment exists`() {
        adapter.existsId(TEST_COMMENT.id) shouldBe true
    }

    @Test
    fun `should exists by id return false when comment does not exist`() {
        adapter.existsId(TEST_COMMENT.id) shouldBe false
    }

    @Test
    @Sql("classpath:test-user.sql",
         "classpath:test-post.sql",
         "classpath:test-comment.sql",
         "classpath:test-comment-vote.sql")
    fun `should update return non null updated comment`() {
        val comment = adapter.loadById(TEST_COMMENT.id)
        comment shouldNotBe null

        comment!!.apply {
            content = "My content"
            created = LocalDateTime.of(2020, 12, 8, 8, 10, 40)
            updated = LocalDateTime.of(2020, 12, 8, 8, 10, 40)
            user = SimpleUser(
                id = TEST_USER.id,
                username = TEST_USER.username
            )
        }

        adapter.update(comment)
        val expected = adapter.loadById(TEST_COMMENT.id)

        comment shouldNotBe null
        comment shouldBe expected
    }

    @Test
    @Sql("classpath:test-user.sql",
         "classpath:test-post.sql",
         "classpath:test-comment.sql",
         "classpath:test-comment-vote.sql")
    fun `should remove by id delete comment when comment exists`() {
        var comment = adapter.loadById(TEST_COMMENT.id)
        comment shouldNotBe null

        adapter.removeById(TEST_COMMENT.id)

        comment = adapter.loadById(TEST_COMMENT.id)
        comment shouldBe null
    }

    companion object {

        @JvmStatic
        fun filtersAndExpectedResults() =
            Stream.of(
                arguments(CommentsFilter.NONE, listOf(TEST_COMMENT)),
                arguments(commentsWith { userId eq TEST_COMMENT.user.id; postId eq TEST_COMMENT.postId; parentId eq null }, listOf(TEST_COMMENT)),
                arguments(commentsWith { userId eq TEST_COMMENT.user.id; postId eq TEST_COMMENT.postId }, listOf(TEST_COMMENT)),
                arguments(commentsWith { userId eq TEST_COMMENT.user.id; parentId eq null }, listOf(TEST_COMMENT)),
                arguments(commentsWith { postId eq TEST_COMMENT.postId; parentId eq null }, listOf(TEST_COMMENT)),
                arguments(commentsWith { userId eq TEST_COMMENT.user.id }, listOf(TEST_COMMENT)),
                arguments(commentsWith { postId eq TEST_COMMENT.postId }, listOf(TEST_COMMENT)),
                arguments(commentsWith { parentId eq null }, listOf(TEST_COMMENT)),
                arguments(commentsWith { parentId eq 1 }, emptyList<Comment>())
            )
    }
}